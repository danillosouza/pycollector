#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
    File: collectord
    Description: Log Collector daemon.
"""

__version_info__ = ('0', '1', '3')
__version__ = '.'.join(__version_info__)
__author__ = "Ronald Kaiser"
__email__ = "ronald at intelie dot com dot br"


import os
import optparse
import subprocess
import sys;
sys.path.append('../conf')
sys.path.append('../src')

from helpers import daemon as daemon

import daemon_conf
from logcollector import LogCollector


def is_running():
    ps = subprocess.Popen("""ps aux | grep "logcollectord .*--start" | grep -v grep | awk {'print $2'}""", 
                          shell=True,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE)
    pids = ps.stdout.read().split('\n')
    current_pid = os.getpid()
    pids = filter(lambda x: x.isdigit(), pids)
    pids = map(lambda x: int(x), pids)
    if current_pid in pids:
        pids.remove(current_pid)
    if len(pids) > 0:
        return (True, pids)
    return (False, pids)


def check_logging_path():
    if not os.path.exists(daemon_conf.LOGGING_PATH):
        print "Logging path configured doesn't exist."
        choice = raw_input('Do you want me to create the directory: %s ? [Y|n] ' % \
                            daemon_conf.LOGGING_PATH)
        if choice == "" or choice.upper() == 'Y':
            return_code = subprocess.call(['mkdir', daemon_conf.LOGGING_PATH], 
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
            if return_code != 0:
                print "Can't create directory."
                sys.exit(-1)
            else:
                print "Logging directory created with success!"


def write_pid():
    pidfile = daemon_conf.PID_PATH
    f = open(pidfile, 'w+')
    f.write(str(os.getpid()))
    f.close()
    os.system("chmod 644 %s" % pidfile)


def status(option, opt, value, parser):
    pidfile = daemon_conf.PID_PATH
    if not pidfile or not os.path.exists(pidfile):
        print "Status: NOT RUNNING."
    else:
        if not is_running()[0]:
            print "Status: NOT RUNNING."
            print "WARNING: Pidfile in %s seems to be obsolete. Please, remove it manually." % daemon_conf.PID_PATH
            sys.exit(-1)
        print "Status: RUNNING."
    sys.exit(0)


def get_pattern_conf(parser):
    filename = parser.values.filename
    if filename:
        if filename.endswith('.py'):
            filename = filename[:-3]
        try:
            exec('from %s import conf as pattern_conf' % filename)
            print "Configuration file in use: %s" % filename
            return pattern_conf
        except Exception, e:
            print "Can't import configuration file. Aborting."
            print e
            exit(-1)
    else:
        try:
            from pattern_conf import conf
            print "Configuration file in use: pattern_conf"
            return conf
        except Exception, e:
            print "Can't import configuration file."
            print e
            exit(-1)


def start(option, opt, value, parser):
    if is_running()[0]:
        print "LogCollector already running."
        sys.exit(-1)
    else:
        pattern_conf = get_pattern_conf(parser)
        print "Starting LogCollector..."
        check_logging_path()
        pidfile = daemon_conf.PID_PATH
        print "LogCollector started."

        d = daemon.DaemonContext(working_directory=os.getcwd())
        #daemon context starts
        d.open()

        write_pid()
        c = LogCollector(pattern_conf, daemon_conf, to_log=True)
        c.start()

        #daemon context finishes
        d.close()


def stop(option, opt, value, parser):
    running, pids = is_running()
    if not running:
        print "LogCollector is not running."
        sys.exit(-1)
    else:
        pidfile = daemon_conf.PID_PATH
        if not pidfile or not os.path.exists(pidfile):
            print "Can't get pidfile: %s. Is it running?" % pidfile
            sys.exit(-1)
        else:
            try:
                print "Stopping LogCollector..."
                f = open(pidfile, 'r')
                pid = int(f.read())
                f.close()
            except Exception, e:
                print "Can't read pidfile. Daemon not stopped."
                sys.exit(-1)
            try:
                cmd = ["kill", "-9"]
                pids = map(lambda x: str(x), pids)
                cmd.extend(pids)
                kill = subprocess.call(cmd,
                                       stdout=subprocess.PIPE,
                                       stderr=subprocess.PIPE)
                if kill != 0:
                    print "Can't stop daemon."
                    sys.exit(-1)
            except Exception, e:
                print e
                print "Can't stop daemon."
                sys.exit(-1)
            else:
                try:
                    rm = subprocess.call(["rm", "-rf", "%s" % pidfile],
                                         stdout=subprocess.PIPE,
                                         stderr=subprocess.PIPE)
                    if rm != 0:
                        print """
    Daemon stopped, but can't remove pidfile.\nRemove manually the file %s.""" % pidfile
                    else:
                        print "LogCollector stopped."
                except Exception, e:
                    print e
                    print """
    Daemon stopped, but can't remove pidfile.\nRemove manually the file %s.""" % pidfile
        sys.exit(0)


if __name__ == '__main__':
    import ascii
    print ascii.ascii

    parser = optparse.OptionParser(prog="LogCollector", version=__version__)
    description = """   
This piece of software reads logs and sends events to AMQ -- based in regular expressions defined in a configuration file."""
    parser.set_description(description)
    parser.add_option("--conf",
                      action="store",
                      dest="filename",
                      help="""pattern configurations filename located at 'conf' 
directory. Use before --start. Default is 'pattern_conf'""")

    parser.add_option("--start",
                      action="callback",
                      callback=start,
                      nargs=0,
                      help="starts LogCollector daemon")

    parser.add_option("--stop",
                      action="callback",
                      callback=stop,
                      nargs=0,
                      help="stops LogCollector daemon")

    parser.add_option("--status",
                      action="callback",
                      callback=status,
                      nargs=0,
                      help="checks if LogCollector daemon is runnning.")

    (options, args) = parser.parse_args()

    if not args:
        parser.print_help()
